\documentclass[a4paper,12pt]{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{lscape}
\usepackage{amsmath}
\usepackage{moreverb}

\title{Projet Nigma : Premiere soutenance}
\author{Guillaume Lapôtre\\Stéphane Ladevie\\Justin Ganivet\\Sébastien Gislais}

\pagestyle{myheadings}
	
\begin{document}
	\markright{Première soutenance du Projet Nigma par la Crypteam}	
	\maketitle{}
	\newpage
	\tableofcontents
	\newpage
	\section{Introduction}
		Voici une petite fiction pour observer le Projet Nigma en situation réelle :\\ \\
Rappelons nous ce célèbre passage du Secret de l’Espadon, la première et la plus belle aventure de Black \& Mortimer (bande dessinée écrit et scénarisé par Edgar P. Jacobs) où le Capitaine Hasso agent de l’Intelligence Service qui, après une réunion de l’état major de l’empereur Basam-Damdu , se précipite dans sa chambre afin de communiquer d’importantes informations aux services secrets Britanniques à l’aide d’un radio émetteur minable. Il lui faut bien 10 minutes pour le régler et il a à peine le temps de révéler une partie de son message que le Colonel Olrik le surprend et l’abat d’une balle dans le dos. On peut supposer qu’avec la totalité du message, les anglais aurait pu se préparer bien mieux pour faire face à l’invasion "jaune" Supposons que ce scénario se soit déroulé dans une autre époque, l’ère du numérique : le capitaine Hasso aurait certainement disposé d’un NetBook dernier cri sur lequel il aurait pu saisir toutes ses notes durant la réunion. Puis il aurait rejoins sa chambre pour transmettre le fruit de son travail aux Anglais mais là il ne prend plus aucun risque grâce à la dernière acquisition des services secrets Britanniques : le Projet Nigma ! En effet grâce à ce programme révolutionnaire le courageux capitaine n’aurait qu’à eu lancer le programme pour crypter les données récoltées et les cacher dans une photo de vacance où on le voit avec ses 5 enfants et sa magnifique femme (personne n’a pensé  à la famille du pauvre capitaine Hasso lorsqu’il s’est fait explosé le dos par le vil Olrik). Cette opération prend à peine une minute, il n’aurait eu par la suite qu’à poster  cette photo modifiée sur son FaceBook (tout le monde a un FaceBook non ?) et les services secrets auraient récupérés toutes ces précieuses informations en consultant simplement le profil FaceBook du capitaine. Le colonel Olrik aurait alors surpris le capitaine Hasso en train de consulter son profil et, à moins de réellement haïr les réseaux sociaux, il n’aurait pas tué l’espion à la solde les Anglais. Le monde aurait été certainement détruit de la même manière mais le capitaine Hasso serait vivant, il n’aurait pas laissé une veuve et 5 orphelins et il aurait certainement reçu une magnifique médaille pour services rendus. Faute de sauver le monde, la Crypteam sauve au moins une vie\dots
	\begin{center}	
		\includegraphics[scale=3]{meteores2.jpg}
	\end{center}
Voici à présent le rapport de la première soutenance du Projet Nigma (Projet d’Info Spé EPITA promotion 2012) de la Crypteam. Nous vous rappelons que le Projet Nigma est un programme informatique de cryptage et de stéganographie dont l’objectif et la protection et la diffusion d’information sur des supports graphiques comme des photos ou des dessins, ce qui le rend utile sur une plateforme internationale comme l’Internet. Ce programme fusionne l’art du secret et l’art de la dissimulation pour offrir une sécurité maximum à l’utilisateur.

ATTENTION : Tout acquéreur d’un logiciel Projet Nigma endosse l’entière responsabilité de ses activités mettant en usage ledit logiciel. La Crypteam ne saurait être tenu pour responsable en cas d’utilisation malhonnête, l’équipe ne fournit qu’un instrument.  

	\newpage
	\section{Cryptographie}
		Au niveau de la cryptographie, nous nous sommes tenu  ce que nous avions prévu dans le cahier des charges. Nous avons donc réalisé le cryptage RSA en Ocaml. Ce cryptage nous a posé plus de difficultées que prévu. Au tout début nous pensions que recoder le RSA était une chose difficile dans la mesure où c'est un algorithme de chiffrement encore utilisé aujourd'hui donc encore efficace (bien que inventé en 1977) puis en se documentant sur la façon dont fonctionne le RSA cela nous a paru relativement simple. En effet sa sécurité est basée sur la difficulté de factoriser un très grand nombre et non pas sur la difficulté à chiffrer/dechifrer un document.
		
		En effet le RSA est un procédé cryptographique asymétrique (ou bien à clé publique), ce qui veut dire qu'au lieu de générer une clé qui permet de chiffrer ainsi que de déchiffrer un message, le RSA génère une clé dite "publique" ainsi qu'une clé dite "privée". Ces deux clés sont intimement liées. Cela veut dire que le RSA génère obligatoirement un couple comportant une clé publique ainsi qu'une clé privée en même temps. La fabrication de la clé privée dépend de la clé publique. 
		
		La clé publique est, comme son nom l'indique publique\dots C'est à dire que l'on peut la partager avec autant de personne que l'on désire. Cette clé permet de chiffrer un message. Par contre une fois le document chiffré, le document n'est déchiffrable que par le détenteur de la clé privée. Ainsi la personne qui a chiffré le message ne peut vérifier si le chiffrement c'est bien déroulé. Cette clé est un couple de deux nombre $(n,e)$. $n$ représente le produit de deux grands nombres premiers\footnote{Appelons-les p et q} (de l'ordre de plusieurs centaines de chiffres!). Et $e$ est un nombre premier avec le produit $(p - 1)(q - 1)$. Pour crypter un texte à l'aide de la clé il faut représenter notre message sous la forme d'un ou de plusieurs entier\footnote{Que nous appellerons $M_{i}$} compris entre $1$ et $n-1$. Le message chiffré est représenté sous la forme des $C_{i} = M_{i}^e \textrm{ mod } n$
		
		La clé privée est la clé permettant de déchiffrer un message chiffré à l'aide de sa clé publique associée. Elle est donc gardée par son propriétaire. Elle est composée elle aussi d'un couple de nombre $(n,d)$. $n$ est identique au $n$ de la clé publique. Et $d$ est tel que $ed \equiv 1 \textrm{ mod } (p - 1)(q - 1)$. Pour déchiffrer un message la procédure est pratiquement identique au chiffrement : On calcule les $D_{i}$ tel que : $D_{i} = C_{i}^d \textrm{ mod } n$
		
		On remarque que le $e$ et le $d$ sont fabriqué à partir des nombres premiers $p$ et $q$. Si l'on pouvait facilement et rapidement factorisé notre $n$ afin de trouver $p$ et $q$ alors le RSA ne servirait plus à rien. C'est précisément parcequ'ils sont premier qu'il est difficile de factoriser $n$.  
		
		\subsection{Partie de Guillaume Lap\^{o}tre}
			J'ai tout d'abord commencer par essayer de créer mes grands nombres premiers puisqu'ils sont le fondement de la 
		cryptographie RSA. J'ai rencontré quelque problème au début car je n'avais pas prévu que les entier était représentés sur 
		31 bits en Ocaml. Ainsi lorsque je voulais créer un grand nombre Ocaml plantait.
		
		J'ai donc fait des recherches afin de 
		trouver comment gérer des grands nombres en Ocaml. J'ai trouvé deux modules satisfaisant à savoir Numerix et Big\_int. Numerix
		n'est pas une bibliothèque native de OCaml mais je l'ai trouvé intéressante car elle comportait déja une fonction pouvant  		
		determiner si un nombre est premier ou non. L'inconvenient non-négligeable est que ces tests de primalité sont efficaces pour 
		un $n < 2^{50}$ or nous voulons des entiers premiers d'au moins un millier de bits. Du coup cette bibliothèque ne nous était 
		plus utile et nous nous sommes rabattu sur la deuxième : Big\_int. Cette dernière à l'avantage d'être une bibliothèque native 
		de Ocaml, ce qui nous permet de l'utiliser sans problème sans avoir à l'installer au préalable.
		
		Big\_int est donc une bibliothèque multi-précision gérant de grands entiers. On peut faire tout ce que l'on faisait déja avec 
		des entiers mais le nom des fonctions est différent. Le "léger" inconvénient est que les opérateur fonctionne en préfixe. Ce 
		qui implique que pour toute les opérations que nous écrivons manipulant des Big\_int sont en notation polonaise. 
		
		Une fois compris comment marchent la plupart des fonctions de Big\_int je me suis intéressé une fois de plus à la création de 
		mes grand nombres premiers.	Pour tester si un $n$ est premier l'algorithme le plus naïf est de tester si aucun $1 < p < 
		\sqrt{n} $ ne divise $n$. Cette algorithme, comme celui  du crible d'Ératosthène, est beaucoup trop long pour trouver si un 
		nombre de plusieurs centaine de chiffres est premier. Il existe donc plusieurs algorithme plus évolué qui sont tous basés 
		plus ou moins sur le petit théorème de Fermat (Si $p$ est un nombre premier et $a \in N $ alors $a^{p - 1} \equiv 
		 1 \textrm{ mod } p$). Ce sont des algorithmes probabilistes, autrement dit lorsque l'on donne un nombre à ce type 
		 d'algorithme, il répond soit "ce nombre est probablement premier" soit "ce nombre est composé". Donc lorsque l'algorithme 
		 renvoie vrai on a pas la certitude que ce nombre est réellement premier. Heureusement ils répondent avec un certain degré de 
		 probabilité. Il existe 3 ou 4 algorithmes probabilistes pouvant être utilisé pour le RSA. Parmis eux il y a Solovay-Strassen, 
		 Lehmann, Miller-Rabin.
		 
		 Cepandant j'ai eut beaucoup de difficultées à coder ces algorithmes en Ocaml. J'ai donc laisser cette partie à l'autre membre 
		 du groupe traitant la cryptographie : Sébastion Gislais. Il expliquera mieux que moi ses péripéties avec les nombres 	
		 premiers.
		 
		 Je suis donc passé à la suite du projet pour le RSA. Donc à la création de mes nombres $e$ et $d$. La fonction générant $e$
		 n'a pas posé trop de souci du fait de sa définition relativement simple. Le nombre $d$ a été un peu plus fastidieux à
		 générer du fait lui aussi de sa définition. Cepandant après quelque visites sur des sites internets expliquant l'algorithme
		 d'Euclide étendu ainsi que sur un livre de la bibliothèque d'EPITA nommé \textit{Cryptographie appliquée} je réussis à 
		 générer mon $d$. Ayant désormais tout les éléments constituant mes clefs privée et publique, je voulais les écrire dans
		 un fichier. Ainsi j'aurais mon fichier avec la clé privé que je conserve jalousement et mon fichier avec la clé publique
		 que je partage avec toute les personnes voulant m'envoyer un message chiffré. J'ai été agréablement surpris par la facilité 
		 de la gestion des fichiers par Ocaml. J'ai ainsi créé mes clefs sans problème. 
		 
		 Une fois mes clés générées, il me fallait maintenant faire le principal : chiffrer et déchiffrer un message. Nous voulions 
		 crypter avant tout du texte, mes clés étant numérique il fallait donc que je transforme mon texte en une suite de nombres.
		 J'ai donc travaillé sur le code ascii de mes caractères. Ainsi ma fonction de cryptage a besoin de la clé publique ainsi que
		 d'un fichier à crypter. Elle récupère chaque code ascii de chaque caractère du fichier, crypte ces caractères et met le
		 résultat crypté dans un nouveau fichier. Ce fichier chiffré et donc constitué d'une liste de code ascii chiffré en RSA.
		 Enfin, pour déchiffrer ce fichier, je déchiffre chaque caractère ascii à l'aide de la clé privée et j'écris le caractère
		 correspondant dans un nouveau fichier. Ainsi je peux vérifier que le fichier d'origine et le fichier chiffré puis déchiffré
		 sont identique !   
		 %Parler ensuite des stratégie pour gérer les fichiers : liste etc...%  
		\newpage 
		\subsection{Partie de Sébastien Gislais}
		\newpage
	\section{Stéganographie}
		\subsection{Partie de Justin Ganivet}
		\newpage
		\subsection{Partie de Stéphane Ladevie}
		
	Je suis un des deux préposés au développement du (fabuleux) module Stéganographie  du Projet Nigma (by Crypteam). Le but de cette fonctionnalité étant de camoufler des informations au sein d’une image de manière à les rendre indécelable à l’œil nu.
Bien que cela puisse paraître futile dans un premier temps, il ne faut pas perdre de vue que nous sommes dans l’ère des médias et de l’information, certains outils comme Internet (via Facebook, Imageshack, MySpace…) permettent des échanges mondiaux de photos et d’images en tout genre.  Grâce au Projet Nigma et par l’intermédiaire de tels outils, l’utilisateur sera en mesure de faire circuler des informations de manière sûre et accessible (réceptionner l’information  ne requiert que le programme et une connexion internet). Il est à noté que Crypteam se décharge de toute responsabilité quand à l’utilisation de son produit à des fins crapuleuses (tel que l’espionnage ou le terrorisme).
Durant cette partie nous appellerons Serge la personne cachant des trucs (ou choses) dans l’image et Jeanne la personne à qui elles sont destinées.

Mon travail a porté sur le décodage de l’information, c'est-à-dire permettre à Jeanne de retrouver les données cachées dans une image de Serge. Les données contenues dans l’image sont toujours sous forme binaire (le fameux langage universel), la raison est simple, le format Bitmap (que nous utilisons dans un premier temps) n’est autre qu’une suite de 1 et de 0 nous offrant ainsi une manipulation relativement simple. Le principe du décodage est très simple, le programme va sauter le header du fichier puis il va parcourir chaque pixel de l’image jusqu’à rencontrer la marque de fin de lecture (un pixel blanc). Pour chaque pixel le programme va regarder la parité des valeurs RGB (Red Green Blue), si la valeur du champ est impaire le programme retourne 1 et si elle est paire elle retourne 0. Par exemple un pixel ayant pour valeur Red = 253, Green = 156, Blue = 127, le programme retournera 101. Ainsi donc Jeanne est contente, elle a réussi à obtenir le message secret que voulait lui transmettre Serge : 1001011100010101100101010… Jeanne est très forte en Volley Ball mais c’est une véritable tache en informatique et elle ne sait donc pas lire le binaire brut (tel l’opérateur de Matrix voyant une femme en robe rouge marcher sur un trottoir), le programme va donc se charger de retranscrire le message binaire dans sa forme originelle : un texte. Pour ce faire nous avons utilisé le code ASCII qui reste relativement simple et universel, à chaque caractère existant correspond une valeur, une fonction va prendre la chaîne de bits pour la convertir en décimal et trouver le caractère correspondant à la valeur obtenue. 
Finalement le prototype de la fonction de décodage est le suivant : la fonction prend en paramètre un nom de fichier (.BMP) et renvoie la chaîne de caractère qui a été caché dedans auparavant. 
Ainsi Jeanne et Serge pourront s’envoyer des messages d’amoureux transis ou des horaires de match sans que personne ne soit au courant, grand bien leur fasse.

J’ai été chargé aussi de réaliser le Main de la Stéganographie.
Nous avons choisi de faire l’encodage et le décodage au sein du même programme pour en faciliter l’utilisation, ces deux cas se distinguent par le premier argument passé en paramètre au programme : 
-e pour l’encodage,
-d pour le décodage. 
Serge n’étant pas un utilisateur modèle ni un gros geek maître dans l’art Unixien il a fallu intégrer une aide simple et claire sur l’utilisation du programme. Pour la consulter il suffit de lancer le programme sans aucun argument, ce qui me semble être le premier réflexe de l’utilisateur lambda. Serge accède alors à une aide interactive :

	\begin{center}	
		\includegraphics[scale=1]{aide1.JPG}
	\end{center}

	\begin{center}	
		\includegraphics[scale=1]{aide3.JPG}
		\textit{En entrant le numéro de la section à consulter comme il est demandé, Serge pourra consulter l’aide sur l’encodage}
	\end{center}


	\begin{center}	
		\includegraphics[scale=1]{aide2.JPG}
		\textit{\\Et pour Jeanne il y’a l’aide sur le décodage}
	\end{center}

L’aide utilisateur va donc décrire les deux utilisations du programme : encodage et décodage, en indiquant les paramètres de chacune et en mettant à disposition un exemple d’utilisation.
  
Un peu de Code à présent !  

La fonction de décodage est construite sur deux boucles : la première est chargée de sauter le header afin de traiter uniquement les pixels codés, la seconde a pour but de traiter chaque pixel de l’image jusqu’à ce qu’elle rencontre un pixel blanc.
Dans un premier temps la fonction principale du décodage fût la suivante:  
\begin{small}
\begin{verbatimtab}
char *decode (char *name)
{
  FILE *src;
  char *res;
  int go_print;
  int jump ;
  int bit_uncoded ;
  pixel bit_coded ;
  res = calloc(1,1);
  jump = 0;
  bit_coded.blue=0;
  bit_coded.green = 0;
  bit_coded.red = 0;
  src = fopen(name,"r");
  for(jump = 0;jump != 54;jump++)
  {
    bit_uncoded = getc(src);
   }
  while(bit_coded.blue == 255 && bit_coded.green == 255 && bit_coded.red == 255)
  {
    bit_coded.blue = getc(src);
    bit_coded.green = getc(src);
    bit_coded.red = getc(src);
    res = strcat(res,pix_to_bit(bit_coded.blue));
    res = strcat(res,pix_to_bit(bit_coded.green));
    res = strcat(res,pix_to_bit(bit_coded.red));
  }
  fclose(src);
  return(res);
}
\end{verbatimtab}
 Où pix\_to\_bit est la fonction qui transforme une valeur R, G ou B d’un pixel en un 0 ou un 1 comme expliqué précédemment : 
\begin{verbatimtab}
char *pix_to_bit (int val)
{
  if(val % 2 == 0)
  {
    return("0");
  }
  else
  {
    return("1");
  }
}
\end{verbatimtab}
Mais nous avons rencontrés un problème à cause du cas d’arrêt :\\
\begin{verbatimtab}
(bit_coded.blue == 255 && bit_coded.green == 255 && bit_coded.red == 255)
\end{verbatimtab}
 En effet la boucle traitait le pixel blanc comme un pixel normal, la fonction renvoyait de manière systématique 111 à la fin de la chaîne de bits. Pour pallier à ce problème j’ai crée une variable entière go\_print que j’ai utilisé à la manière d’un booléen (les booléens nécessitant l’utilisation d’une bibliothèque spécifique en C) pour forcer le programme à ne pas traiter le dernier pixel. La nouvelle boucle est donc :   \\
\begin{verbatimtab}
  int go_print;
  go_print = 1;/* déclaration et initialisation de la nouvelle variable */

  while(go_print)
  {
    bit_coded.blue = getc(src);
    bit_coded.green = getc(src);
    bit_coded.red = getc(src);
    if(bit_coded.blue == 255 && bit_coded.green == 255 && bit_coded.red == 255)
    {
      go_print = 0;
    }
    else
    {
      res = strcat(res,pix_to_bit(bit_coded.blue));
      res = strcat(res,pix_to_bit(bit_coded.green));
      res = strcat(res,pix_to_bit(bit_coded.red));
    }
  }
  fclose(src);
  return(res);
}
\end{verbatimtab}
\end{small}

Finalement une fois le principe de notre module de stéganographie établit avec l’aide de Justin ainsi que l’encodage réalisé par ce même comparse, il n’a pas été très difficile de faire la fonction inverse (mis à part le problème mentionné ci-dessus). Le travail sur la stéganographie a surtout porté sur la mise en place du concept, sur le fonctionnement du format bitmap et sur le principe de la manipulation des pixels. Ainsi j’ai eu le temps d’aider mes deux collègues chargés de la cryptographie au niveau des maths fondamentales sur les tests de primalités et l’établissement des clés publiques et privées (algorithme d’Euler étendu).

	
		\newpage
	\section{Site web}
	\newpage
	\section{Conclusion}
	\newpage
	\section{Annexe}
		\subsection {Screenshot Steganographie}
		\newpage
		\begin{landscape}
		\subsection {Screenshot Cryptographie}
			\begin{center}
				\includegraphics[scale=0.42]{cryptage.jpg}\\
					\textit{En haut le texte à chiffrer}\\ 
					\textit{En milieu le texte chiffré puis déchiffré}\\ 
					\textit{En bas le texte chiffré}\\ 
			\end{center}
		\end{landscape}
		\newpage
\end{document}