\documentclass[a4paper,12pt]{article}

\usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{lscape}
\usepackage{amsmath}
%\usepackage{moreverb}
\usepackage{hyperref}
\hypersetup{colorlinks, citecolor=black, filecolor=black, linkcolor=black, urlcolor=black}
%\usepackage{fancyhdr}

\title{Projet Nigma : Deuxième soutenance}
\author{CrypTeam : LAPÔTRE Guillaume (\texttt{lapotr\_g}) \and GANIVET Justin (\texttt{ganive\_j}) \and LADEVIE Stéphane (\texttt{ladevi\_s}) \and GISLAIS Sébastien (\texttt{gislai\_s})}
\date{}

\pagestyle{myheadings}

\begin{document}

\markright{Deuxième soutenance du Projet Nigma par la Crypteam}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Introduction}
\newpage
\section{Cryptographie}
	Cette fois-ci encore, nous avons respecté ce que nous avions prévu de présenter pour cette seconde soutenance. En effet nous avons implémenté l'algorithme DES (Data Encryption Standard). Contrairement au RSA présenté en première soutenance, le DES est un algorithme de chiffrement symétrique. Cela signifie que pour chiffrer ou déchiffrer un fichier on utilise la même clé. Ce type de chiffrement a ses avantages et inconvénients par rapport au chiffrement asymétrique. Son principal avantage est sa rapidité : il est 1000 fois plus rapide que le RSA ! Son principal inconvénient est le fait de ne possèder qu'une seule clé. Ainsi le problème principal est l'échange de cette clé entre les différents protagonistes qui veulent échanger des données chiffrées. En effet pour le RSA il suffisait de donner sa clé publique aux personnes désirant chiffrer des messages, ensuite ils renvoient les messages chiffrés et on peut les déchiffrer à l'aide de notre clé privé jamais échangé avec personne. Si l'on envoie notre clé DES au n'importe qui, il y a un risque qu'un pirate puisse intercepté la clé et donc s'en servir ensuite pour déchiffrer les messages confidentiels. Cepandant il y a une astuce permettant de contourner le problème : On chiffre la clé DES avec un chiffrement RSA ! 
	
	Un petit exemple : Alice veut envoyer un message confidentiel à Bob. Bob crée donc un jeu de clé RSA puis envoie la clé publique à Alice. Alice crée sa clé DES, puis chiffre son message à envoyer avec cette clé. Finalement, elle envoie à Bob sa clé DES chiffrée avec la clé publique RSA ainsi que le message chiffré avec la clés DES. Bob reçoit donc les deux fichiers, avec sa clé privé RSA il déchiffrer le fichier de clé envoyé par Alice, puis avec la clé DES qu'il vient de déchiffrer il peut déchiffrer le message d'Alice !
	
	Le DES a été achevé en 1977, c'est donc un algorithme de chiffrement ancien. Sa sécurité n'est plus optimale, en effet un état peut casser une clé DES en quelque minutes maintenant. Cepandant nons pensons qu'il est intéressant de se pencher sur cet algorithme qui fût un des premiers algorithmes de chiffrement symétrique défini rigoureusement.
	
	Du fait de son ancienneté les spécifications du DES étaient prévus pour une réalisation matérielle. C'est à dire pour que ce soit des puces qui réalisent le chiffrement. Ainsi certaines partie du protocole sont faciles à réaliser sur une puce mais sont difficile à réaliser en Ocaml. Nous développerons dans nos parties respectives.

\newpage

\subsection{Partie de Guillaume Lapôtre}
	Pour implémenter le DES en Ocaml je me suis tout d'abord documenté sur cet algorithme de chiffrement complexe bien qu'utilisant que des opérations basiques	(en effet le DES est optimisé pour une réalisation matérielle \dots). Je me suis donc basé sur un livre qui m'a été bien utile pour la l'implémentation de RSA qui se nomme "Cryptographie Appliquée" par Bruce Schenier. Ce livre est très pratique car il explique très bien comment fonctionne un bon nombre d'algorithme de chiffrement et il y a aussi l'histoire de chaque algorithme : Comment il a été créé, par qui, suite à quels besoins etc\ldots \\
	
	J'ai donc tout d'abord commencé par la création d'un clé DES. Sa création fût bien plus simple que la création d'une paire de clé RSA. En effet, la génération des clefs RSA nécessitent de possèder au préalable de grands nombres premiers qui furent quelque peu difficile à obtenir. Une clé DES est un nombre de 64 bits. Puis le DES ne se sert que de 56 bits des 64 bits présents initialement. Les 8 bits inutilisés sont des bits de parités. Ils servent à vérifier lorsque l'on envoie la clé que la clé reçue n'est pas corrompue. C'est à dire qu'aucun bit n'a changé au court du transfert. Ainsi, une clé DES à la propriété d'avoir un nombre pair de bits à 1 pour chaque octet. Ce sont les 8 bits de parité qui permettent d'assurer cette propriété.
	
	On remarque déja que l'on va manipuler beaucoup de données au bit à bit. Je me suis donc poser la question afin de me determiner dans la manipulation de nombre codés sur 32 à 64 bits. J'ai donc tout d'abord fait des fonctions permettant les manipulations de base sur les bits d'un nombre : acceder au ième bits d'un nombre et mettre à 1 ou à 0 la valeur d'un bit d'un nombre. Puis, pour faciliter la manipulation des bits de mes nombres et la vérification de mes fonctions j'ai codé une fonction qui nous a servi tout au long de la réalisation du DES, cette dernière prend un nombre en paramètre et renvoi un tableau contenant dans chacune de ses cases les bits du nombre. Ainsi, dans la case 0 il y a le bit numero 0 et ainsi de suite. J'ai bien sur codé sa fonction réciproque qui prend en paramètre un tableau contenant tout les bits d'un nombres et qui renvoie le nombre. Avec ces deux fonctions on à pu réaliser tout les manipulations que l'on voulais sur nos blocs.
	
	Je me suis ensuite occupé des différentes fonctions de manipulation de la clef. Tout d'abord il y a une permutation de clef qui réarrange les bits dans un ordre prédéfini et qui ignore les bits de parité. On se retrouve donc avec une clé de 56 bits. Ensuite à chaque ronde du DES \footnote{le protocole exacte d'une ronde du DES sera expliquée par Sébastien}, on sépare la clé en deux sous-clés de 28 bits chacune et on effectue une ou deux rotations gauche suivant la ronde que l'on est en train d'effectuer. Ensuite on réassemble les deux sous clé puis on effectue une permutation compressive qui compresse la clé qui était de 56 bits en une clé de 48 bits. L'orde de lequel les bits sont réarrangés est spécifié dans le DES. Ainsi j'ai pu générer les 16 sous-clés requises pour le chiffrement d'un bloc.\\
	
	Je me suis ensuite occupé d'une toute autre partie dans l'algorithme DES qui est la gestion des S-box ou tables de substitution. Ces tables sont le point-clé dans la sécurité du DES. En effet elles sont les seuls éléments non linéaire dans cet algorithme et elles confèrent à l'algorithme son niveau de sécurité. La chose qui pourrait paraître étonnante est que les 8 tables de substitutions du DES sont totalement publiques maintenant. Ces tables de substitution se représentent initialement sous la forme d'un tableau à deux entrées. La méthode permettant d'acceder à la case du tableau que l'on recherche est un peu particulière\footnote{Encore une fois, Sébastien expliquera dans sa partie exactement quand est-ce que l'on s'en sert.}.
	Nous avons donc initialement un bloc de 48 bits que nos tables de subsitutions vont transformer en un bloc de 32 bits de façon absolument pas linéaire.
	Nos tables ont 4 rangs et 16 colonnes. Découpons notre bloc de 48 bits en 8 sous-blocs de 6 bits. Prenons notre premier sous-bloc et nommons les bits qui le compose : b1 b2 b3 b4 b5 b6. Le nombre composé par les deux bits b1 b6 va permettre la selection du rang puis les 4 autres bits b2 b3 b4 b5 vont permettre de selectionner la colonne, le tout sur la table de substitution n°1. Ainsi nous avons donc selectionner une case de notre tableau qui contient un nombre sur 4 bits. En faisant de même pour les 8 sous-blocs on a donc utilisé les 8 tables de substitutions et récupéré les 32 bits escomptés. 
	
	On peut remarquer que la sélection d'un case dans une table n'est pas forcément une chose aisée dûe à la façon dont on utilise les bits de nos sous-blocs. En effet en réalisation matérielle cette sélection ne pose pas de problème par contre en réalisation logicielle ce n'est pas optimisé. J'ai donc réarrangé les s-box pour obtenir 8 tableaux à une dimension en remettant bien dans l'ordre les bits b1 b2 b3 b4 b5 b6. Ainsi lorsque j'utilise une table je n'ai besoin que du bon sous-bloc de 6 bits pour récuperer sa représentation décimale et avoir le numéro de la case du tableau que je veux ! Par ailleurs, cela me permet aussi de limiter les risques de mauvaise utilisation des tables de substitutions. 

	Voici un exemple de l'utilisation d'une table de substitution avec le nombre 27 donc la représentation en binaire est  $\%011011$ \\

	\begin{center}	
	  \includegraphics[scale=0.75]{s-box.jpg}\\
  	\textit{\\Voici une S-box où l'on voit bien le nombre "b1 b6"  pour la sélection de la ligne et le nombre "b2 b3 b4 b5" pour la selection de la 	colonne}\\
	\end{center}
	On voit donc sur l'image ci-dessus quelle cellule est sélectionnée. La table de substitution nous renvoie donc $\%1001$ soit en décimal le nombre 9. \\
	
	Puis j'ai travaillé sur la création de la fonction principale. Cette dernière gère les fonctions de chiffrage de données, de déchiffrage ainsi que la fonction de création de la clef. Cette fonction gère aussi tout la partie accès/écriture/lecture dans les différents fichiers utiles. Ainsi, lorsque l'on appelle le programme avec le paramètre --clef, le programme crée un fichier nommé clefDES et écrit une clef dedans avec les bits de parité à jour. Lorsque l'on appelle le programme avec le paramètre --chiffre, il faut lui donner en deuxième paramètre le fichier à chiffrer et en troisième paramètre le fichier contenant une clé DES. Le programme ouvre le fichier contenant la clé pour la récuperer puis crée les 16 sous-clé. Ensuite il ouvre le fichier à chiffrer et récupère les 8 premiers caractères. Comme un caractère est représenté sur un octet donc sur 8 bits, les 8 caractères lu donnent donc 64 bits. Ensuite on chiffre ces 64 bits avec les 16 sous-clefs et on écrit les 8 nouveaux caractères correspondant au bloc de 64 bits chiffré. Puis on fait de même pour chaque bloc de 8 caractère du fichier à chiffrer. Comme un fichier ne contient pas forcément un multiple de 8 caractères et, par contre, le DES à besoin de bloc de 64 bits, nous avons trouvé une astuce pour que le dernier bloc soit aussi chiffré : On complète le bloc avec des caractère espace pour avoir au final un bloc de 8 caractères. C'est pour cela que nos fichiers chiffrés contiennent tout le temps un multiple de 8 caractères. 

\newpage
\subsection {Partie de Sébastien Gislais}
\newpage
\section {Stéganographie}
\subsection {Partie de Justin Ganivet}
\newpage
\subsection {Partie de Stéphane Ladevie}
\newpage
\section {Conclusion}
	Cette préparation de soutenance fût donc encore une fois un expérience fort enrichissante. Nous avons rencontré plein d'obstacle mais le fait de les surpasser les uns après les autres nous a fait progresser ! 
	
	Du coté de la cryptographie, nous avons donc appris le maniement d'un nouvel algorithme de chiffrement qui est le DES. Etant un algorithme de chiffrement symétrique cela nous à permis de nous diversifier par rapport au premier algorithme implémenté : le RSA qui est un algorithme de chiffrement asymétrique. De plus, on peut dire que ces algorithmes sont complémentaires. En effet, le DES a pour avantage sa rapidité tandis que le RSA a pour avantage sa sécurité. De plus comme il est expliqué dans la partie Cryptographie, un des principaux défauts du DES est contourné grâce au RSA : l'échange de l'unique clé de chiffrement et de déchiffrement DES est normalement complexe à effectuer de manière sûre mais si l'on chiffre la clé DES à l'aide du RSA nous n'avons plus ce problème !
	
	Du coté de la stéganographie, on peut voir que nous avons aussi bien avancé, nous avons deux nouveaux algorithmes de stéganographie plus performants que le premier présenté en première soutenance. L'appararition d'un application graphique est aussi une bonne chose. Notre programme sera donc plus accessible et plus facile à utiliser par l'utilisateur lambda.
	
	Pour la soutenance finale nous présenterons donc un dernier algorithme de chiffrement qui est l'AES. Comme le DES, c'est aussi un algorithme de chiffrement symétrique par contre étant plus récent que le DES, son niveau de sécurité est bien plus important. Nous aurons aussi bien sûr une application graphique finalisée et on ne verra plus que nous avons un programme de cryptographie et un programme de stéganographie car l'application graphique réunira tout les programmes nécéssaires pour chiffrer un fichier à l'aide de l'algorithme choisi et le cacher dans l'image sélectionnée.
\newpage
%
%\section{Annexe}

%\begin{landscape}
 % \subsection {Screenshot Cryptographie}
  %\begin{center}
	%\end{center}
%\end{landscape}

\end{document}